-- Task 1
SELECT C.CLASS,
       YEAR(MIN(B.DATE)) as FIRST_BATTLE,
       YEAR(MAX(B.DATE)) AS LAST_BATTLE,
       COUNT(DISTINCT B.NAME) AS ALL_BATTLES
FROM CLASSES C
JOIN SHIPS S ON C.CLASS=S.CLASS
LEFT JOIN OUTCOMES O ON S.NAME=O.SHIP
LEFT JOIN BATTLES B ON O.BATTLE=B.NAME
WHERE S.CLASS LIKE 'N%'
GROUP BY C.CLASS;


-- Task 2
SELECT BATTLE, TYPE, COUNT(*) COUNT FROM OUTCOMES O
JOIN SHIPS S ON O.SHIP=S.NAME
JOIN CLASSES C ON C.CLASS=S.CLASS
GROUP BY BATTLE, TYPE;
# +----------------+------+-------+
# | BATTLE         | TYPE | COUNT |
# +----------------+------+-------+
# | Guadalcanal    | bb   |     3 |
# | Guadalcanal    | bc   |     1 |
# | North Atlantic | bb   |     5 |
# | North Cape     | bc   |     1 |
# | North Cape     | bb   |     1 |
# | Surigao Strait | bb   |     5 |
# +----------------+------+-------+
# 6 rows in set (0.00 sec)

-- Now I have to take only those whose bb count is higher than bc count
-- I JOIN THOSE WITH BB AND BC TOGETHER AND FILTER OUT THE BATTLES THAT DO NOT MATCH REQUIREMENTS

SELECT A.BATTLE FROM
(SELECT BATTLE, TYPE, COUNT(*) BBCOUNT FROM OUTCOMES O JOIN SHIPS S ON O.SHIP=S.NAME JOIN CLASSES C ON C.CLASS=S.CLASS GROUP BY BATTLE, TYPE HAVING TYPE='bb') A
LEFT JOIN
(SELECT BATTLE, TYPE, COUNT(*) BCCOUNT FROM OUTCOMES O JOIN SHIPS S ON O.SHIP=S.NAME JOIN CLASSES C ON C.CLASS=S.CLASS GROUP BY BATTLE, TYPE HAVING TYPE='bc') B
ON A.BATTLE=B.BATTLE
WHERE BBCOUNT > BCCOUNT OR (BBCOUNT IS NOT NULL AND BCCOUNT IS NULL);


-- Task 2 alternative approach
SELECT NAME FROM BATTLES
WHERE
(SELECT COUNT(*) FROM OUTCOMES O JOIN SHIPS S ON O.SHIP=S.NAME JOIN CLASSES C ON C.CLASS=S.CLASS WHERE C.TYPE='bb' AND O.BATTLE=BATTLES.NAME)
>
(SELECT COUNT(*) FROM OUTCOMES O JOIN SHIPS S ON O.SHIP=S.NAME JOIN CLASSES C ON C.CLASS=S.CLASS WHERE C.TYPE='bc' AND O.BATTLE=BATTLES.NAME);